#pragma once

#include "tx/common.hxx"
#include "tx/hash_murmur.hxx"
#include "tx/object.hxx"
#include "tx/value.hxx"

#include <span>
#include <string_view>
#include <type_traits>

namespace tx {

// Pseudo random non-null numbers generated using following commented code
inline constexpr u32 HASH_NIL = 0x1735b84b;
inline constexpr u32 HASH_FALSE = 0x7674b793;
inline constexpr u32 HASH_TRUE = 0x4a2da019;
// clang-format off
// std::random_device rd;  // Will be used to obtain a seed
// std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()
// std::uniform_int_distribution<std::uint32_t> distrib(
//     1,
//     std::numeric_limits<uint32_t>::max()
// );
// for (int n=0; n<3; ++n)
//     // Use `distrib` to transform the random unsigned int generated by gen
//     // into an int in specified range
//     std::cout << std::hex << distrib(gen) << ' ';
// std::cout << '\n';
// clang-format on

template <typename Key>
struct Hash;

template <typename Key>
    requires(std::is_fundamental_v<Key> || std::is_pointer_v<Key>)
struct Hash<Key> {
    constexpr u32 operator()(const Key& val) const noexcept {
        return murmur3_32(std::span<const std::byte>(
            static_cast<const std::byte*>(static_cast<const void*>(&val)),
            sizeof(Key)
        ));
    }
};

template <>
struct Hash<std::string_view> {
    constexpr u32 operator()(const std::string_view& strv) const noexcept {
        return murmur3_32(std::span<const std::byte>(
            static_cast<const std::byte*>(static_cast<const void*>(strv.data())
            ),
            strv.length()
        ));
    }
};

template <>
struct Hash<Obj> {
    constexpr u32 operator()(const Obj& obj) const noexcept {
        switch (obj.type) {
            using enum Obj::ObjType;
            case STRING: return obj.as<ObjString>().hash;
            case CLOSURE:
            case FUNCTION:
            case NATIVE:
            case UPVALUE:
                // FIXME: Hashing the address do not make sense
                // better to implement for real of cause crash
                // TODO: make this work without "const"
                return Hash<const Obj*>()(&obj);
        }
        unreachable();
    }
};

template <>
struct Hash<Value> {
    constexpr u32 operator()(Value const& val) const noexcept {
        switch (val.type) {
            using enum Value::ValueType;
            case NONE: unreachable();
            case NIL: return HASH_NIL;
            case BOOL: return val.as_bool() ? HASH_TRUE : HASH_FALSE;
            case CHAR: return Hash<char32_t>()(val.as_char());
            case INT: return Hash<int_t>()(val.as_int());
            case FLOAT: return Hash<float_t>()(val.as_float());
            case OBJECT: return Hash<Obj>()(val.as_object());
        }
        unreachable();
    }
};

}  // namespace tx
